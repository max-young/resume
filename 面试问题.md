<!-- TOC -->

- [自我介绍](#自我介绍)
- [面试问题](#面试问题)
  - [C++](#c)
  - [图形学](#图形学)
  - [几何](#几何)
- [我问的问题](#我问的问题)

<!-- /TOC -->

<a id="markdown-自我介绍" name="自我介绍"></a>
### 自我介绍

### 项目经验

1. 考试星
2. 得到电商平台
3. 2D游戏

设计到OpenGL的方方面面, 比如坐标变换, 捕捉键盘输入, 碰撞检测, framebuffer实现特性, 还包括音效等等

4. 渲染

这个项目设计到渲染会比较多, 比如PBR

<a id="markdown-面试问题" name="面试问题"></a>
### 面试问题

<a id="markdown-c" name="c"></a>
#### C++

1. C++的编译过程  
   4个步骤:  
   第一步是预编译, 例如讲const变量和include替换成原始值和原始代码  
   第二步是就代码编译成汇编语言  
   第三步是将汇编语言编译成机器码  
   第四步是链接其它文件和库, 生成可执行文件

2. C和C++的区别  
   C++是面向对象的, 它可以通过类来实现封装、继承和多态  
   C的效率更高.

3. C++单例  
   单例可以用class的static member来实现, 比如定义一个static member count, 在构造函数里加上count的限制, 来实现单例.
   单例可以用在一些全局的对象的场景, 比如数据库的链接

4. static  
   static有两个应用场景.  
   一个是在class里面, 代表class自身的静态成员. 例如class的member function加上static, 那么我们就不用实例化class之后, 用实例化对象来调用这个函数, 而是用clas就可以直接调用. 和python里的classmethod装饰器类似.  
   另外也可以用在function里面, 函数执行完成了, static变量的lifetime并不会消亡, 所以, 假如定义一个函数, 函数里有一个static int变量, 初始化值是0, 然后自增, 那么重复调用这个函数, 这个static变量会一直累加上去.

5. this以及class static能不能用this  
   this就是class的const pointer, 它可以用arrow operator来访问class的member data.  
   static function不能用this, 因为static function是和class相关的, 不是和其实例化对象相关. static function里只能访问static member data.

6. vector push的内存变化  
   往vector push_back数据时, 因为是连续存储的, 如果内存不够, 那么就需要重新分配内存, 这样效率会非常低. 所以这个时候会分配比实际需要更大的内存, 来保证vector能够存放的数据, 而不用频繁分配内存.

7. 线程如何同步  
   线程之间需要同步动作, 例如一个线程执行完一个动作之后, 其它线程才能执行另外的动作. 推荐的方法是有C++的标准库, 利用condition variable, 用condition variable来通知其它线程可以执行其它动作了.

8. weak_ptr  
   weak_ptr和shared_ptr关联, shared_ptr计算对象的引用数量, weak_ptr可以用shared_ptr初始化, 执行同一个对象, 但是不计入引用数量.  
   这样我们可以用weak_ptr的lock方法来检查是否对象还在, 然后生成其有效的shared_ptr.

9. 右值move  
    copy需要将对象复制一份, 然后马上被销毁, 开销比较大. 而且如果对象是自定义的, 那么它还必须是可复制的.  
    move可以解决这两个问题, 效率更高, 也不用要求对象是可复制的.

    move跟rvalue reference相关, 我们一般说的reference都是左值引用, 右值引用可以和右值关联, 因为右值是临时的, 马上就会被销毁, 所以可以被自由的使用.  

    move可以把左值转换成右值引用, 然后去实现复制.

10. 左值和右值的区别  
    左值是对象的标识, 也就是内存中的位置. 右值是这个对象的值, 也就是内容.

11. reference和pointer的区别  
    reference和pointer都可以间接访问对象.  
    reference只是对象的一个别名. 而pointer是一个对象, 和其他对象一样, 都是占有内存的.
    reference初始化必须有已存在的对象, pointer初始化则不必须, 可以为空.

12. 多态的几种形式
13. 子类如何找到父类, class的内存管理、内存布局, rtti
14. 模板
15. 广度优先搜索实现
16. map的数据结构
17. 线程池的实现
18. 内存的管理
19. 为什么用到指针  
    只有必要时才用pointer. 例如类型缺失, 可以用`void*`.  
    例如我们要创建一个将一个字符串a复制给另一个字符串b的函数, 第一个参数可以是字符串a的const reference, 第二个参数可以是字符串b的指针.

    
<a id="markdown-图形学" name="图形学"></a>
#### 图形学

1. shadow mapping如何实现, shadow volume是什么?  
   shadow mapping和z-buffer有点类似, 只是z-buffer是从camera出发最近的物体表面, 而shadow maping是指从光源出发最近的物体表面.  
   在做渲染的时候根据深度测试找到要渲染的点, 然后把这个点和光源的距离计算出来, 和shadow mapp的值做比较, 如果相等则是被光源照亮, 如果大于, 则是处在阴影中.

   shadow volume是指一个光源和遮挡物构成一个锥体, 以遮挡物为界, 上面的部分能把照亮, 下面的部分处在阴影中, 这一部分就称之为shadow volume. 从camera出发和场景中的一个点相连, 用这条线和锥体求交点, 如果交点数量是奇数, 则这个点处在阴影中.

2. z-fighting  
   打个比方, 一张桌子上面放一张纸, 由于纸太薄了, 在做深度测试的时候可能就会变出现问题, 导致渲染出来出现桌子戳破的情况. 这就是z-fighting.

   如果是从正射角度看这个场景, 可能提高z-buffer的精度就能解决. 但是很多时候是从侧面看, 可能就需要别的转换等方法来解决.

3. alpha测试、stencil测试  
   alpha测试可以实现透明, 比如从纹理数据时, 除了rgb, 还有alpha值, 我们可以设定一个alpha值, 如果alpha值小于这个值, 那就舍弃点不渲染. 还可以实现blend混合的效果, 渲染的颜色是前景和背景的混合.  
   stencil测试是指根据stencil buffer实现一些效果, 比如最简单的是stencil buffer的一部分是1, 一部分是0, 是1的部分才渲染. 一种边框的效果也可以用stencil buffer实现.

4. TBN空间  
   比如一个三角形是一个平面, 如果它比较大, 那么就不能表现实际的凹凸的细节, 我们可以增加三角形, 但是这个方法开销太大.  
   如何在不增加几何元素的情况下, 更加逼真的表现细节呢?  
   可以用bump mapping, 用法线贴图来表现凹凸的细节.  
   法线数据应该存储在哪个坐标系下呢? 这就是TBN空间. 它是一个local坐标系, 不和特定场景绑定, 可以复用.

5. shader如何渲染一条任意长度的线
   
6. texture纹理槽不够怎么办  
   将两个精度为4bit的属性压缩到一个8bit的通道里.  
   或者将多个小贴图合并成一个大贴图.

7. 高斯filter如何实现
8. 上万个object渲染, 如何提高效率
9.  如何实现鼠标点选
10. mipmap
11. 各向异性, 各向同性
12. 光栅化的原理, 过程
13. antialiasing
    超采样, 开销太大. 低采样导致摩尔纹, 用卷积filter还原.
14. 纹理过程
    用generateTexture创建一个纹理.  
    bindtexture绑定纹理, 之后的操作都是在这个纹理上处理.  
    然后可以用texparameteri函数设置环绕、过滤方式  
    然后用stb_image库从图片文件加载图片数据, 用图片数据生成纹理, 如果是2D的, 那就用glTexImg2D函数.
15. 阴影的原理 
   
<a id="markdown-几何" name="几何"></a>
#### 几何

1. 点和线的距离  
   先可以有起始点p加上t乘以一个方向单位向量v来表示, 点Y到这条线的距离就是它到线的垂足的点的距离, 这两个点的向量和线的方向向量是垂直的, 那么他们的点乘就是0, 从而可以求得垂足, 从而就可以求得距离.  
   如果是射线, 那么需要判断Y和P的点乘是否大于0, 大于0说明垂足在射线上, 用刚才的算法, 小于等于0则说明垂足在射线的反方向上, 距离就等于Y和P的距离.

2. 点是否在多边形内部    
   先说三角形, 三角形构成一个重心坐标系, 我们可以算出这个点在重心坐标系下的坐标, 如果都大于0, 那么说明这个点在三角形内部.  
   对于多边形, 可以从这个点往任意方向发射一条射线, 例如往x轴发射, 然后看这个多边形有多少条边和这条射线相交, 如果相交的数量是奇数, 则这个点在这个多边形的内部.  
   或者也可以把多边形切分成三角形来挨个判断.

3. 一组点的最小多边形  
   可以用凸包算法, 选取任意一个点, 作为坐标系的原点, 然后遍历求得其它点相对于这个点的极角, 然后从小到大排列, 最小的那个一点在多边形上, 然后第二个点连第三个点, 构成一条线, 如果第四个点在这条线的左边, 那么第三个点就是多边形的顶点, 如果在右边, 那么第三个点就不是, 那就连第二个点和第四个点, 这样遍历下去.

4. 一个向量如何旋转90度  
   我们拿二维向量来说, 逆时针旋转90度就是xy交换, 乘以一个0110的2*2的矩阵就可以实现.  
   旋转任意角度是乘以一个cos theta sin theta的2\*2矩阵

5. 如何从一个坐标系转换到另一个坐标系
   可以用仿射变换, 先旋转再平移, 平移的话需要用到齐次坐标.

<a id="markdown-我问的问题" name="我问的问题"></a>
### 我问的问题

1. 项目内容
2. 产品是还在研发阶段还是已经商用了?
3. 项目的研发过程中有哪些难点和挑战?
4. 我面试的职位的工作内容
