<!-- TOC -->

- [自我介绍](#自我介绍)
- [面试问题](#面试问题)
  - [C++](#c)
  - [图形学](#图形学)
  - [几何](#几何)
- [我问的问题](#我问的问题)

<!-- /TOC -->

<a id="markdown-自我介绍" name="自我介绍"></a>
### 自我介绍

### 项目经验

1. 考试星
2. 得到电商平台
3. 2D游戏

设计到OpenGL的方方面面, 比如坐标变换, 捕捉键盘输入, 碰撞检测, framebuffer实现特性, 还包括音效等等

4. 渲染

这个项目设计到渲染会比较多, 比如PBR

<a id="markdown-面试问题" name="面试问题"></a>
### 面试问题

<a id="markdown-c" name="c"></a>
#### C++

1. C++的编译过程  
   4个步骤:  
   第一步是预编译, 例如讲const变量和include替换成原始值和原始代码  
   第二步是就代码编译成汇编语言  
   第三步是将汇编语言编译成机器码  
   第四步是链接其它文件和库, 生成可执行文件

2. C和C++的区别  
   C++是面向对象的, 它可以通过类来实现封装、继承和多态  
   C的效率更高.

3. C++单例  
   单例可以用class的static member来实现, 比如定义一个static member count, 在构造函数里加上count的限制, 来实现单例.
   单例可以用在一些全局的对象的场景, 比如数据库的链接

4. static  
   static有两个应用场景.  
   一个是在class里面, 代表class自身的静态成员. 例如class的member function加上static, 那么我们就不用实例化class之后, 用实例化对象来调用这个函数, 而是用clas就可以直接调用. 和python里的classmethod装饰器类似.  
   另外也可以用在function里面, 函数执行完成了, static变量的lifetime并不会消亡, 所以, 假如定义一个函数, 函数里有一个static int变量, 初始化值是0, 然后自增, 那么重复调用这个函数, 这个static变量会一直累加上去.

5. this以及class static能不能用this  
   this就是class的const pointer, 它可以用arrow operator来访问class的member data.  
   static function不能用this, 因为static function是和class相关的, 不是和其实例化对象相关. static function里只能访问static member data.

6. vector push的内存变化  
   往vector push_back数据时, 因为是连续存储的, 如果内存不够, 那么就需要重新分配内存, 这样效率会非常低. 所以这个时候会分配比实际需要更大的内存, 来保证vector能够存放的数据, 而不用频繁分配内存.

7. 线程如何同步  
   线程之间需要同步动作, 例如一个线程执行完一个动作之后, 其它线程才能执行另外的动作. 推荐的方法是有C++的标准库, 利用condition variable, 用condition variable来通知其它线程可以执行其它动作了.

8. weak_ptr  
   weak_ptr和shared_ptr关联, shared_ptr计算对象的引用数量, weak_ptr可以用shared_ptr初始化, 执行同一个对象, 但是不计入引用数量.  
   这样我们可以用weak_ptr的lock方法来检查是否对象还在, 然后生成其有效的shared_ptr.

9. 右值move  
    copy需要将对象复制一份, 然后马上被销毁, 开销比较大. 而且如果对象是自定义的, 那么它还必须是可复制的.  
    move可以解决这两个问题, 效率更高, 也不用要求对象是可复制的.

    move跟rvalue reference相关, 我们一般说的reference都是左值引用, 右值引用可以和右值关联, 因为右值是临时的, 马上就会被销毁, 所以可以被自由的使用.  

    move可以把左值转换成右值引用, 然后去实现复制.

10. 左值和右值的区别  
    左值是对象的标识, 也就是内存中的位置. 右值是这个对象的值, 也就是内容.

11. reference和pointer的区别
    reference和pointer都可以间接访问对象.  
    reference只是对象的一个别名. 而pointer是一个对象, 和其他对象一样, 都是占有内存的.
    reference初始化必须有已存在的对象, pointer初始化则不必须, 可以为空.

<a id="markdown-图形学" name="图形学"></a>
#### 图形学

1. shadow mapping如何实现, shadow volume是什么?
2. z-fighting
3. alpha测试、stencil测试
4. TBN空间
5. shader如何渲染一条任意长度的线
6. texture纹理槽不够怎么办
7. 高斯filter如何实现
8. 上万个object渲染, 如何提高效率
9. 如何实现鼠标点选
   
<a id="markdown-几何" name="几何"></a>
#### 几何

1. 点和线的距离  
   先可以有起始点p加上t乘以一个方向单位向量v来表示, 点Y到这条线的距离就是它到线的垂足的点的距离, 这两个点的向量和线的方向向量是垂直的, 那么他们的点乘就是0, 从而可以求得垂足, 从而就可以求得距离.  
   如果是射线, 那么需要判断Y和P的点乘是否大于0, 大于0说明垂足在射线上, 用刚才的算法, 小于等于0则说明垂足在射线的反方向上, 距离就等于Y和P的距离.

2. 点是否在多边形内部    
   先说三角形, 三角形构成一个重心坐标系, 我们可以算出这个点在重心坐标系下的坐标, 如果都大于0, 那么说明这个点在三角形内部.  
   对于多边形, 可以从这个点往任意方向发射一条射线, 例如往x轴发射, 然后看这个多边形有多少条边和这条射线相交, 如果相交的数量是奇数, 则这个点在这个多边形的内部.  
   或者也可以把多边形切分成三角形来挨个判断.

3. 一组点的最小多边形  
   可以用凸包算法, 选取任意一个点, 作为坐标系的原点, 然后遍历求得其它点相对于这个点的极角, 然后从小到大排列, 最小的那个一点在多边形上, 然后第二个点连第三个点, 构成一条线, 如果第四个点在这条线的左边, 那么第三个点就是多边形的顶点, 如果在右边, 那么第三个点就不是, 那就连第二个点和第四个点, 这样遍历下去.

4. 一个向量如何旋转90度  
   我们拿二维向量来说, 逆时针旋转90度就是xy交换, 乘以一个0110的2*2的矩阵就可以实现.  
   旋转任意角度是乘以一个cos theta sin theta的2*2矩阵

5. 如何从一个坐标系转换到另一个坐标系

  可以用访射变换, 先旋转再平移, 平移的话需要用到齐次坐标.

<a id="markdown-我问的问题" name="我问的问题"></a>
### 我问的问题

1. 项目内容
2. 项目有哪些挑战
3. 我面试的职位的工作内容